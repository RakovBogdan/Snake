class Snake {
	
	field Grid grid;
	field SnakePart head, tail;
	field int snakeLength;

	constructor Snake new(int length, int width) {
		let grid = Grid.new(width);
		let snakeLength = length;
		do createSnake();
		return this;
	}

	method void createSnake() {
		var int partsCreated;
		let head = SnakePart.new(0, 0);
		do grid.drawBlock(0, 0);
		let tail = head;
		let partsCreated = 1;
		
		while(partsCreated < snakeLength) {
			do head.setNext(SnakePart.new(partsCreated, 0));
			do grid.drawBlock(partsCreated, 0);
			let head = head.getNext();
			let partsCreated = partsCreated + 1;
		}

		return;
	}

	method int getLength() {
		return snakeLength;
	}

	method Grid getGrid() {
		return grid;
	}

	method SnakePart getHead() {
		return head;
	}

	method Array calculateCoordinatesInDirection(int direction) {
		var Array result;
		var int headX;
		var int headY;
	
		let headX = head.getXIndex();
		let headY = head.getYIndex();
		let result = Array.new(2);
	
		if (direction = SnakeGame.getRight()) {
			let headX = headX + 1;
		}
		if (direction = SnakeGame.getLeft()) {
			let headX = headX - 1;
		}
		if (direction = SnakeGame.getUp()) {
			let headY = headY - 1;
		}
		if (direction = SnakeGame.getDown()) {
			let headY = headY + 1;
		}
		
		let result[0] = headX;
		let result[1] = headY;
		
		return result;
	}

	method boolean checkSnakeNextMoveIsInGrid(int direction) {
		var Array nextCoordinates;
		let nextCoordinates	= calculateCoordinatesInDirection(direction);
		return grid.isCoordinateInGrid(nextCoordinates[0], nextCoordinates[1]);
	}

	method boolean nextMoveCollides(int direction) {
		var Array nextCoordinates;
		let nextCoordinates	= calculateCoordinatesInDirection(direction);
		return grid.isCoordinateOccupied(nextCoordinates[0], nextCoordinates[1]);
	}
	
	method void eat(int direction) {
		var Array nextCoordinates;
		let nextCoordinates	= calculateCoordinatesInDirection(direction);
		do head.setNext(SnakePart.new(nextCoordinates[0], nextCoordinates[1]));
		do grid.drawBlock(nextCoordinates[0], nextCoordinates[1]);
		let head = head.getNext(); 
		let snakeLength = snakeLength + 1;
		return;
	}
	
	
	method void move(int direction) {
		var Array nextCoordinates;
		let nextCoordinates	= calculateCoordinatesInDirection(direction);

		do removeTail();
		do head.setNext(SnakePart.new(nextCoordinates[0], nextCoordinates[1]));
		do grid.drawBlock(nextCoordinates[0], nextCoordinates[1]);
		let head = head.getNext(); 
		return;
	}
	

	method void removeTail() {
		var SnakePart tailToRemove;
		let tailToRemove = tail;
		let tail = tail.getNext();
		do grid.eraseBlock(tailToRemove.getXIndex(), tailToRemove.getYIndex());
		do tailToRemove.dispose();
		return;
	}

	method void eraseSnakeFromScreen() {
		var SnakePart partToErase;
		let partToErase = tail;

		while (~(partToErase = null)) {
			do grid.eraseBlock(partToErase.getXIndex(), partToErase.getYIndex());
			let partToErase = partToErase.getNext();
		}

		return;	
	}

	method void drawSnakeOnScreen() {
		var SnakePart partToDraw;
		let partToDraw = tail;

		while (~(partToDraw = null)) {
			do grid.drawBlock(partToDraw.getXIndex(), partToDraw.getYIndex());
			let partToDraw = partToDraw.getNext();
		}
		
		return;	
	}

	method void dispose() {
		while (~(tail = null)) {
			do removeTail();
		}

		do grid.dispose();
		do Memory.deAlloc(this);
		return;
	}
}