class SnakeGame {

	static int xPixelSize;
	static int yPixelSize;
	static int exitButton; //'q' button
	static int leftButton;
	static int rightButton;
	static int upButton;
	static int downButton;
	static int left;
	static int right;
	static int up;
	static int down;

	field Snake snake;
	field int direction;
	field Grid grid;
	field Array food;

	function int getLeft() {
		return left;
	}
	
	function int getRight() {
		return right;
	}
	
	function int getUp() {
		return up;
	}
	
	function int getDown() {
		return down;
	}
	
	constructor SnakeGame new() {
		var int snakeLength;
		var int snakeWidth;
		let yPixelSize = 256;
		let xPixelSize = 512;
		let exitButton = 81;
		let leftButton = 130;
		let upButton = 131;
		let rightButton = 132;
		let downButton = 133;
		let left = 1;
		let up = 2;
		let right = 3;
		let down = 4;

		let snakeWidth = 16;
		let snake = Snake.new(snakeLength, snakeWidth);
		let grid = snake.getGrid();
		let direction = right;
		
		do LCGRandom.setSeed(0);
		return this;
	} 

	method void start() {
		var int currentKeyPressed;
		var boolean exit;

		let exit = false;
        do generateFoodOnGrid();
        
		while (~(exit)) {
			let currentKeyPressed = Keyboard.keyPressed();
			if (currentKeyPressed = exitButton) {
				let exit = true;
			}

			do readDirection(currentKeyPressed);

			if (checkIfNextBlockIsFood()) {
				do eatFood();
			} else {
				let exit = ~(moveSnake());
			}
		}

		do Output.moveCursor(11, 0);
		do Output.printString("Game over, score: ");
		do Output.printInt(snake.getLength());

		return;
	}

	method void generateFoodOnGrid() {
		var Array foodCoordinates;
        var SnakePart head;
		var int numberOfSteps;
        
        let head = snake.getHead();
		let numberOfSteps = LCGRandom.randRange(1, grid.getSize() - snake.getLength());
		
		let foodCoordinates = grid.getNextBlockAfterSteps(head.getXIndex(),
			head.getYIndex(), numberOfSteps);

		if (~(grid.isCoordinateEmpty(foodCoordinates[0], foodCoordinates[1]))) {
			let foodCoordinates = grid.drawNextEmptyBlock(foodCoordinates[0], foodCoordinates[1]);
		} else {
			do grid.drawBlock(foodCoordinates[0], foodCoordinates[1]);
		}

		let food = foodCoordinates;

		return;
	}

	method boolean moveSnake() {
		if (~(snake.checkSnakeNextMoveIsInGrid(direction)) | snake.nextMoveCollides(direction)) {
			return false;
		}

		do snake.move(direction);
		do Sys.wait(100);
		return true;
	}
	
	method boolean checkIfNextBlockIsFood() {
		var Array nextCoordinates;
		let nextCoordinates	= snake.calculateCoordinatesInDirection(direction);

		return ((food[0] = nextCoordinates[0]) & (food[1] = nextCoordinates[1]));
	}

	method void eatFood() {
		do snake.eat(direction);
		do Sys.wait(100);
		do generateFoodOnGrid();
		return;
	}

	method void readDirection(int currentKeyPressed) {
		if ((currentKeyPressed = leftButton) & ~(direction = right)) {
			let direction = left;
		}
		if ((currentKeyPressed = upButton) & ~(direction = down)) {
			let direction = up;
		}
		if ((currentKeyPressed = rightButton) & ~(direction = left)) {
			let direction = right;
		}
		if ((currentKeyPressed = downButton) & ~(direction = up)) {
			let direction = down;
		}
		return;
	}

	method void dispose() {
		do snake.dispose();
		do Memory.deAlloc(this);
		return;
	}
}